# 我是彩笔
很久没刷LeetCode，让本来就菜的我雪上加霜。第一道刷的这个题，easy难度，把劳资想破头也没想出优雅的解法，只好看了题解。真鸡儿丢人，以后不能再这么拉胯了。

# 题目描述
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:

现有矩阵 matrix 如下：

[

  [1,   4,  7, 11, 15],

  [2,   5,  8, 12, 19],

  [3,   6,  9, 16, 22],

  [10, 13, 14, 17, 24],

  [18, 21, 23, 26, 30]

]

给定 target = 5，返回 true。

给定 target = 20，返回 false。

限制：

0 <= n <= 1000

0 <= m <= 1000


注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/

链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof

# 解题思路
一开始想的是，一维数组用二分法，那二维数组也用相同的思想，拿一个矩阵的中心位置和target比较，然后确定target在这个矩阵的哪个象限。但仔细一想，可以举出一些反例，来说明这种比较根本不能确定target的位置，也就不能缩小范围。
其它简单办法（比如执行n行或者m列的二分查找）又肯定不是最优解，最后只能看题解。

**解法：** 从右上角出发，先向左走，直到遇到一个比target小的数，此时再往左走肯定找不到target，因为会更小，所以往下走，向增大的方向走。到下一个数的时候是同样的逻辑：**比target小就向下走，反之向左走**，总共就两个方向。

类似这种路径：
[

  [1,   4,  **7**, **11**, **15**],

  [2,   5,  **8**, 12, 19],

  [3,   **6**,  **9**, 16, 22],

  [10, 13, 14, 17, 24],

  [18, 21, 23, 26, 30]

]

**为什么这种走法保证不漏？**
1. 首先这种走法不会错过行数：比如target在第2行，肯定不会走到target右边区域的第三行，因为target同一行的右边更大，此时会向左转，不会继续往下走；
2. 其次这种走法不会错过列数：比如target在第3列，不可能跑到第2列去找，因为在第3列的第1行，因为小于target，就一定会往下走。

**为什么选择右上角？**
从左上角出发，无论是向右走还是向下走都是增大，没办法判断怎么走，右下角同理。
左下角其实也可以：当前位置比target小就往右走，比target大就往上走。

# 总结
这种二维数组的题，可以考虑一个pos走来走去的解法。