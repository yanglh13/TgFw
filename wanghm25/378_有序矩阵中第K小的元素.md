# 题目

给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

示例：

matrix = [

   [ 1,  5,  9],

   [10, 11, 13],

   [12, 13, 15]

],

k = 8, 返回 13。

提示：你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2

# 我的解法

基本思路就是n路归并排序，每一行是一路，用n个元素的数组来记录**当前行**归并到了哪一列，只需排序到第k个即可。

以题目中的矩阵为例，有数组：

count == 0 ->  &nbsp;&nbsp;[ 0 0 0 ]&nbsp;&nbsp;&nbsp;&nbsp;     //刚开始的时候

count == 1 ->&nbsp;&nbsp;  [ 1 0 0 ]&nbsp;&nbsp;&nbsp;&nbsp;     //排出第一个数，第一行变为1

这个数组代表的n个数只能通过遍历一遍来选出最小值。以此类推。

这种方法的复杂度是O(kn)，可能退化到O(n^2)。而且只用到了每一行有序，每一列有序的性质其实没有用到，所以肯定不是最优解。

**另外，顺便可以发现一个规律：在题目限定的矩阵上，上面的数组一直是降序**

# 最优解

利用上面发现的规律，其实可以得到官方题解中提到的结论：

**任取一个数 mid 满足 l ≤ mid ≤ r，那么矩阵中不大于 mid 的数，肯定全部分布在矩阵的左上角**，其中l、r分别是最大值最小值。

按照如下走法，可以计算出矩阵中小于等于某个数的元素个数：
可以这样描述走法：

* 初始位置在 matrix[n - 1][0]（即左下角）；

* 设当前位置为 matrix[i][j]。若 matrix[i][j] ≤ mid，则将当前所在列的不大于 mid 的数的数量（即 i + 1 ）累加到答案中，并向右移动，否则向上移动；

* 不断移动直到走出格子为止。

总之就是蛇形走位，算出个数来。那为啥要算这个东西呢？居然是因为要**二分查找！！**

引用题解的话：
```
不妨假设答案为 x，那么可以知道 l ≤ x ≤ r，这样就确定了二分查找的上下界。

每次对于「猜测」的答案 mid，计算矩阵中有多少数不大于 mid ：
1. 如果数量不少于 k，那么说明最终答案 x 不大于 mid；
2. 如果数量少于 k，那么说明最终答案 x 大于 mid。

这样我们就可以计算出最终的结果 x 了。

```

# 总结

1. 这种矩阵的规律，就是小于等于某个数的元素，都分布在左上角。

2. 求第k大的数，我只知道排前n个序，但这题秒在，由于可以方便地求得比某个数大/小的元素个数，进而可以判断出这个数在排序后的位置

唉草泥马劳资根本就不懂这东西为什么这么做，以后完全看懂了再补充